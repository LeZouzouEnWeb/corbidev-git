name: Dev Deploy (after PR)

on:
  pull_request:
    branches: [ develop ]
    types: [ closed ] # déclenché quand la PR est fermée (on vérifie merged ci-dessous)

permissions:
  contents: read

concurrency:
  group: dev-deploy-${{ github.event.pull_request.head.ref }}
  cancel-in-progress: true

env:
  REMOTE_CHEMIN: ${{ secrets.REMOTE_CHEMIN }}
  ADRESSE_GLOBAL: ${{ vars.ADRESSE_GLOBAL }}
  ADRESSE_LOCAL: ${{ vars.ADRESSE_LOCAL }}
  SFTP_HOST: ${{ secrets.SFTP_HOST }}
  SFTP_USER: ${{ secrets.SFTP_USER }}
  SFTP_PORT: ${{ secrets.SFTP_PORT }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

jobs:
  deploy:
    name: Déployer sur le serveur DEV
    if: ${{ github.event.pull_request.merged == true }} # uniquement si la PR a été mergée
    runs-on: ubuntu-latest

    steps:
      - name: Vérifier variables requises
        shell: bash
        run: |
          miss=0
          for v in REMOTE_CHEMIN ADRESSE_GLOBAL ADRESSE_LOCAL SFTP_HOST SFTP_USER SSH_PRIVATE_KEY; do
            if [ -z "${!v}" ]; then
              echo "::error title=Variable manquante::$v n'est pas défini."
              miss=1
            else
              echo "::notice title=Variable::$v=${!v}"
            fi
          done
          [ "$miss" -eq 0 ] || exit 1

      - name: Récupérer le code
        uses: actions/checkout@v4

      - name: Construire le chemin distant normalisé (sans création)
        id: path
        shell: bash
        run: |
          norm() { printf "%s" "$1" | sed -e 's#//*#/#g' -e 's#^/##' -e 's#/$##'; }
          _remote="$(norm "$REMOTE_CHEMIN")"
          _glob="$(norm "$ADRESSE_GLOBAL")"
          _loca="$(norm "$ADRESSE_LOCAL")"

          # Chemin attendu : REMOTE_CHEMIN/ADRESSE_GLOBAL/dev/ADRESSE_LOCAL
          REMOTE_PATH="/${_remote}/${_glob}/dev/${_loca}"
          REMOTE_PATH="$(echo "$REMOTE_PATH" | sed -e 's#//*#/#g')"

          echo "REMOTE_PATH=$REMOTE_PATH" >> "$GITHUB_OUTPUT"
          echo "::notice title=REMOTE_PATH::$REMOTE_PATH"

      - name: Préparer l’agent SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.SSH_PRIVATE_KEY }}

      - name: Ajout hôte dans known_hosts
        shell: bash
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${SFTP_PORT:-22}" "$SFTP_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          chmod 600 ~/.ssh/known_hosts

      - name: Vérifier la connexion SSH
        shell: bash
        run: |
          ssh -o BatchMode=yes -o StrictHostKeyChecking=yes -p "${SFTP_PORT:-22}" "$SFTP_USER@$SFTP_HOST" "echo 'Connexion SSH OK'"

      - name: Déployer les fichiers (rsync avec .rsync-ignore si présent)
        shell: bash
        run: |
          REMOTE_PATH="${{ steps.path.outputs.REMOTE_PATH }}"
          echo "Déploiement vers : $REMOTE_PATH"

          # Fail si le dossier n'existe pas (on NE LE CREE PAS)
          ssh -p "${SFTP_PORT:-22}" "$SFTP_USER@$SFTP_HOST" "[ -d \"$REMOTE_PATH\" ]" \
            || { echo "::error title=Dossier distant manquant::Le dossier $REMOTE_PATH n'existe pas."; exit 1; }

          # Prépare les exclusions (.rsync-ignore si présent)
          RSYNC_EXCLUDES=(--exclude='.git/' --exclude='.github/')
          if [ -f ".rsync-ignore" ]; then
            echo "::notice title=rsync::Utilisation de .rsync-ignore"
            RSYNC_EXCLUDES+=(--exclude-from='.rsync-ignore')
          else
            echo "::notice title=rsync::Aucun .rsync-ignore trouvé à la racine du dépôt"
          fi

          # Synchronisation (idempotente) + suppression des fichiers retirés côté source
          rsync -az --delete \
            "${RSYNC_EXCLUDES[@]}" \
            -e "ssh -p ${SFTP_PORT:-22}" \
            ./ "$SFTP_USER@$SFTP_HOST:$REMOTE_PATH/"

          echo "✅ Déploiement terminé."
