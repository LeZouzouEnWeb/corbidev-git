name: PR requires linked issue

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]


permissions:
  contents: read
  pull-requests: read
  issues: read

jobs:
  check-linked-issue:
    runs-on: ubuntu-latest
    env:
  # Exemples 2 pris en charge :
  #  - #123
  #  - PROJ-1234
  #  - close/fix/resolve #123
  #  - ticket-123  | ticket 123 | ticket_123   ‚Üê (NOUVEAU)
      TICKET_REGEX: '(?:\\B#(?<num>\\d+)\\b|[A-Z][A-Z0-9_]+-(?<num>\\d+)\\b|(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\\s+#(?<num>\\d+)|ticket[-_ ]?(?<num>\\d+)\\b)'
    steps:
      - name: V√©rifier les liaisons via GraphQL + regex
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const prNumber = pr.number;

            // 1) Cherche issues li√©es via closing keywords dans le body (fallback texte brut)
            const body = (pr.body || "").toLowerCase();
            const closingKeywordRegex = /\b(close[sd]?|fix(e[sd])?|resolve[sd]?)\s+#\d+\b/gi;
            const hasClosingKeyword = closingKeywordRegex.test(body);

            // 2) Interroge l‚ÄôAPI GraphQL pour closingIssuesReferences (les issues que GitHub fermera √† la merge)
            const query = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  pullRequest(number:$number) {
                    closingIssuesReferences(first: 20) {
                      nodes { number url title }
                    }
                  }
                }
              }
            `;
            const data = await github.graphql(query, { owner, repo, number: prNumber });
            const closing = data?.repository?.pullRequest?.closingIssuesReferences?.nodes ?? [];
            const hasClosingIssuesRefs = closing.length > 0;

            // 3) V√©rifie titre et branche contre un regex de ticket configurable
            const ticketPattern = new RegExp(process.env.TICKET_REGEX, 'i');
            const title = pr.title || "";
            const headRef = pr.head?.ref || "";
            const hasTicketInTitle = ticketPattern.test(title);
            const hasTicketInBranch = ticketPattern.test(headRef);

            // R√©sum√© pour logs
            core.info(`PR #${prNumber} ‚Äî title="${title}" branch="${headRef}"`);
            core.info(`closingIssuesReferences: ${closing.length}`);
            closing.forEach(i => core.info(`- closes #${i.number} ${i.url}`));
            core.info(`hasClosingKeyword=${hasClosingKeyword}, hasTicketInTitle=${hasTicketInTitle}, hasTicketInBranch=${hasTicketInBranch}`);

            const ok = hasClosingIssuesRefs || hasClosingKeyword || hasTicketInTitle || hasTicketInBranch;

            if (!ok) {
              const tips = [
                "üß© Lier une issue avec un mot-cl√© dans la description, p.ex. `Closes #123`",
                "üè∑Ô∏è Inclure l‚Äôidentifiant du ticket dans le *titre* de la PR, p.ex. `PROJ-1234: Corrige le bug X`",
                "üåø Inclure l‚Äôidentifiant du ticket dans le *nom de branche*, p.ex. `feature/PROJ-1234/‚Ä¶`",
              ].join("\\n");

              core.setFailed(
                "Cette PR n‚Äôest li√©e √† aucun ticket/issue d√©tect√©.\n\n" +
                "Accepte l‚Äôun des crit√®res suivants :\n" + tips + "\n\n" +
                `Regex utilis√©: ${process.env.TICKET_REGEX}`
              );
            } else {
              core.info("‚úÖ PR li√©e √† un ticket/issue : contr√¥le valid√©.");
            }
