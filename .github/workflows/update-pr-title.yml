name: üîÑ Normalize PR title (#num ‚Üí "[#num] rest of title")

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  update-title:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Normalize PR title
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info("Pas de pull_request dans ce contexte.");
              return;
            }

            const origTitle = pr.title || "";
            const branch = pr.head?.ref || "";

            // D√©j√† normalis√© ? [#123] ...
            if (/^\s*\[#\d+\]\s+/i.test(origTitle)) {
              core.info("Le titre semble d√©j√† normalis√©, aucune action.");
              return;
            }

            // 1) D√©tection du num√©ro (#123 > ticket-123|ticket 123 > ABC-123 > '... 123/...').
            function findTicketNum(s) {
              if (!s) return null;
              let m;
              m = s.match(/#(\d{1,8})\b/);                if (m) return m[1];
              m = s.match(/ticket[-_\s]?(\d{1,8})\b/i);    if (m) return m[1];
              m = s.match(/[A-Z][A-Z0-9_]*-(\d{1,8})\b/);  if (m) return m[1];
              m = s.match(/(^|[^\d])(\d{1,8})(?=\s*\/)/);  if (m) return m[2];
              return null;
            }

            const num = findTicketNum(origTitle) || findTicketNum(branch);
            if (!num) {
              core.info("Aucun num√©ro d√©tect√© dans le titre/branche.");
              return;
            }

            // 2) Extraire la partie 'apr√®s le num√©ro'
            function tailAfterNumber(s, n) {
              if (!s) return "";
              const idxHash   = s.search(new RegExp(`#${n}\\b`));
              const idxTicket = s.search(new RegExp(`ticket[-_\\s]?${n}\\b`, "i"));
              const idxJira   = s.search(new RegExp(`[A-Z][A-Z0-9_]*-${n}\\b`));

              const reNumSlash = new RegExp(`(^|[^\\d])(${n})(\\s*\\/)(.*)$`);

              let after = "";
              if (idxHash >= 0) {
                after = s.slice(idxHash + (`#${n}`).length);
              } else if (idxTicket >= 0) {
                // "ticket{sep}{n}" ‚Üí coupe ici, on nettoiera ensuite
                after = s.slice(idxTicket + ("ticket".length + String(n).length + 1));
              } else if (idxJira >= 0) {
                const m = s.match(new RegExp(`[A-Z][A-Z0-9_]*-${n}\\b`));
                after = s.slice(idxJira + (m ? m[0].length : 0));
              } else if (reNumSlash.test(s)) {
                after = s.replace(reNumSlash, "$4");
              } else {
                // fallback: supprime tout jusqu'au n¬∞ et prend la suite
                const reBefore = new RegExp(`^.*?${n}\\b[\\s_\\-\\/]*`);
                after = s.replace(reBefore, "");
              }

              // Nettoyage s√©parateurs
              after = after
                .replace(/^[\s:_\-\/]+/, " ")
                .replace(/[\/_\-]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();

              return after;
            }

            let tail = tailAfterNumber(origTitle, num);
            if (!tail) tail = tailAfterNumber(branch, num);
            if (!tail) {
              tail = origTitle
                .replace(/^[\s\[\(\{]*[^\d#A-Z]*?/i, "")
                .replace(/^[\s:_\-\/]+/, " ")
                .replace(/[\/_\-]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();
            }

            // 3) SUPPRIMER "ticket" PARTOUT (d√©but, apr√®s s√©parateur, OU coll√© au mot suivant)
            //    - ex: "ticket-48", "ticket 48", "ticketErreur" ‚Üí tous supprim√©s.
            tail = tail
              // cas s√©par√©: d√©but OU apr√®s s√©parateur
              .replace(/(^|[\s:_\-\/])ticket\b(?:[-_\/\s]+)?/gi, " ")
              // cas coll√© au mot suivant (ticketerreur)
              .replace(/(^|[\s:_\-\/])ticket(?=[A-Za-z√Ä-√ø])/gi, " ")
              .replace(/\s+/g, " ")
              .trim();

            // 4) R√©cup√©rer le pr√©fixe (ex: "Fixbug") au d√©but du titre d'origine avant un s√©parateur
            const catMatch = origTitle.match(/^\s*([A-Za-z][A-Za-z0-9]*)\s*[\/:_\-]/);
            if (catMatch) {
              const cat = catMatch[1];
              const reBeginsWithCat = new RegExp("^" + cat + "\\b", "i");
              if (!reBeginsWithCat.test(tail)) {
                tail = (cat + " - " + tail).replace(/\s+/g, " ").trim();
              } else {
                const reCatSep = new RegExp("^" + cat + "\\b[\\s:_\\-\\/]*", "i");
                tail = tail.replace(reCatSep, cat + " - ");
              }
              tail = tail.replace(/\s+/g, " ").trim();
            }

            const newTitle = `[#${num}] ${tail}`.trim();

            if (newTitle && newTitle !== origTitle) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                title: newTitle
              });
              core.info(`Titre mis √† jour: "${origTitle}" ‚Üí "${newTitle}"`);
            } else {
              core.info("Aucun changement appliqu√© au titre.");
            }