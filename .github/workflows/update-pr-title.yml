name: üîÑ Normalize PR title (#num ‚Üí "[#num] rest of title")

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  update-title:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Normalize PR title
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info("Pas de pull_request dans ce contexte.");
              return;
            }

            const origTitle = pr.title || "";
            const branch = pr.head && pr.head.ref ? pr.head.ref : "";

            // Si le titre est d√©j√† normalis√© [#123] ..., on sort.
            if (/^\s*\[#\d+\]\s+/i.test(origTitle)) {
              core.info("Le titre semble d√©j√† normalis√©, aucune action.");
              return;
            }

            // Recherche du num√©ro: priorit√©s (#123) > ticket-123/ticket 123 > JIRA ABC-123 > nombre avec /
            function findTicketNum(s) {
              if (!s) return null;
              let m;
              m = s.match(/#(\d{1,8})\b/); if (m) return m[1];
              m = s.match(/ticket[-_\s]?(\d{1,8})\b/i); if (m) return m[1];
              m = s.match(/[A-Z][A-Z0-9_]*-(\d{1,8})\b/); if (m) return m[1];
              // nombre suivi d'un slash
              m = s.match(/(^|[^\d])(\d{1,8})(?=\s*\/)/); if (m) return m[2];
              return null;
            }

            const num = findTicketNum(origTitle) || findTicketNum(branch);
            if (!num) {
              core.info("Aucun num√©ro de ticket d√©tect√© dans le titre ni la branche.");
              return;
            }

            // D√©duire la partie 'apr√®s le num√©ro' depuis titre (ou branche)
            function tailAfterNumber(s, n) {
              if (!s) return "";
              const idxHash   = s.search(new RegExp(`#${n}\b`));
              const idxTicket = s.search(new RegExp(`ticket[-_\s]?${n}\b`, 'i'));
              const idxJira   = s.search(new RegExp(`[A-Z][A-Z0-9_]*-${n}\b`));

              // motif "nombre suivi d'un /"
              const reNumSlash = new RegExp(`(^|[^\d])(${n})(\s*\/)(.*)$`);

              let after = "";
              if (idxHash >= 0) {
                after = s.slice(idxHash + (`#${n}`).length);
              } else if (idxTicket >= 0) {
                // on coupe apr√®s "ticket{sep}{n}", le nettoyage uniformisera
                after = s.slice(idxTicket + (`ticket`.length + String(n).length + 1));
              } else if (idxJira >= 0) {
                after = s.slice(idxJira + (s.match(new RegExp(`[A-Z][A-Z0-9_]*-${n}\b`))[0].length));
              } else if (reNumSlash.test(s)) {
                after = s.replace(reNumSlash, "$4");
              } else {
                // fallback : supprime tout jusqu'au n¬∞ et prend ce qui suit
                const reBefore = new RegExp(`^.*?${n}\b[\s_\-\/]*`);
                after = s.replace(reBefore, "");
              }

              // Nettoyage des s√©parateurs et pr√©fixes communs
              after = after
                .replace(/^[\s:_\-\/]+/, " ")
                .replace(/[\/_\-]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();

              return after;
            }

            let tail = tailAfterNumber(origTitle, num);
            if (!tail) tail = tailAfterNumber(branch, num);
            if (!tail) {
              tail = origTitle
                .replace(/^[\s\[\(\{]*[^\d#A-Z]*?/i, "")
                .replace(/^[\s:_\-\/]+/, " ")
                .replace(/[\/_\-]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();
            }

            // --- Post-traitement minimal ---
            // 1) supprimer un "ticket" r√©siduel, m√™me s'il est coll√© au mot suivant
            tail = tail
              .replace(/^ticket\b[\s:_\-\/]+/i, "")
              .replace(/^ticket(?=[A-Za-z√Ä-√ø])/i, "")
              .replace(/^\s+/, "")
              .trim();

            // 2) r√©cup√©rer le pr√©fixe textuel initial du titre (ex: Fixbug) et ins√©rer " - "
            const catMatch = origTitle.match(/^\s*([A-Za-z][A-Za-z0-9]*)\s*[\/:_\-]/);
            if (catMatch) {
              const cat = catMatch[1];
              if (!new RegExp(`^${cat}\\b`, "i").test(tail)) {
                tail = `${cat} - ${tail}`.replace(/\s+/g, " ").trim();
              } else {
                tail = tail.replace(new RegExp(`^${cat}\\b[\s:_\-\/]*`, "i"), `${cat} - `);
              }
              tail = tail.replace(/\s+/g, " ").trim();
            }
            // --- Fin post-traitement ---

            const newTitle = `[#${num}] ${tail}`.trim();

            if (newTitle && newTitle !== origTitle) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                title: newTitle
              });
              core.info(`Titre mis √† jour: "${origTitle}" ‚Üí "${newTitle}"`);
            } else {
              core.info("Aucun changement appliqu√© au titre.");
            }