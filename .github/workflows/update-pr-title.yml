name: üîÑ Normalize PR title (#num ‚Üí "[#num] rest of title")
'on':
  pull_request:
    types:
    - opened
    - edited
    - synchronize
    - ready_for_review
    - reopened
permissions:
  contents: read
  pull-requests: write
jobs:
  update-title:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
    - name: Normalize PR title
      uses: actions/github-script@v7
      with:
        script: "const pr = context.payload.pull_request;\nif (!pr) {\n  core.info(\"\
          Pas de pull_request dans ce contexte.\");\n  return;\n}\n\nconst origTitle\
          \ = pr.title || \"\";\nconst branch = pr.head && pr.head.ref ? pr.head.ref\
          \ : \"\";\n\n// Si le titre est d√©j√† normalis√© [#123] ..., on sort.\nif\
          \ (/^\\s*\\[#\\d+\\]\\s+/i.test(origTitle)) {\n  core.info(\"Le titre semble\
          \ d√©j√† normalis√©, aucune action.\");\n  return;\n}\n\n// Recherche du num√©ro:\
          \ priorit√©s (#123) > ticket-123/ticket 123 > JIRA ABC-123 > nombre suivi\
          \ d'un /\nfunction findTicketNum(s) {\n  if (!s) return null;\n  let m;\n\
          \  m = s.match(/#(\\d{1,8})\\b/); if (m) return m[1];\n  m = s.match(/ticket[-_\\\
          s]?(\\d{1,8})\\b/i); if (m) return m[1];\n  m = s.match(/[A-Z][A-Z0-9_]*-(\\\
          d{1,8})\\b/); if (m) return m[1];\n  // Nombre avant un slash (ex: \"...\
          \ 4/creer ...\" ou \"...ticket/4/..\")\n  m = s.match(/(^|[^\\d])(\\d{1,8})(?=\\\
          s*\\/)/); if (m) return m[2];\n  return null;\n}\n\n// Dans quel texte chercher\
          \ ? D'abord le titre, puis la branche\nconst num = findTicketNum(origTitle)\
          \ || findTicketNum(branch);\nif (!num) {\n  core.info(\"Aucun num√©ro de\
          \ ticket d√©tect√© dans le titre ni la branche.\");\n  return;\n}\n\n// D√©duire\
          \ la partie 'apr√®s le num√©ro' √† partir du titre (ou de la branche si plus\
          \ parlant).\nfunction tailAfterNumber(s, n) {
  if (!s) return \"\";
  const reBefore = new RegExp(`^.*?${n}\\b[\\s_\-\/]*`, \"i\");
  let after = s.replace(reBefore, \"\");

  // Nettoyage: normaliser espaces et s√©parateurs
  after = after
    .replace(/^[\s:_\-\/]+/, \" \")
    .replace(/[\/\_\-]+/g, \" \")
    .replace(/\s+/g, \" \")
    .trim();

  return after;
}\n\n// Utiliser le titre en priorit√©\
          \ comme source du libell√© apr√®s le num√©ro; sinon la branche.\nlet tail =\
          \ tailAfterNumber(origTitle, num);\nif (!tail) {\n  tail = tailAfterNumber(branch,\
          \ num);\n}\n\n// Si rien trouv√©, on garde l'ancien titre d√©pollu√©.\nif (!tail)\
          \ {\n  tail = origTitle\n    .replace(/^[\\s\\[\\(\\{]*[^\\d#A-Z]*?/i, \"\
          \")\n    .replace(/^[\\s:_\\-\\/]+/, \" \")\n    .replace(/[\\/_\\-]+/g,\
          \ \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n// Construit\
          \ le nouveau titre\nconst newTitle = `[#${num}] ${tail}`.trim();\n\nif (newTitle\
          \ && newTitle !== origTitle) {\n  await github.rest.pulls.update({\n   \
          \ owner: context.repo.owner,\n    repo: context.repo.repo,\n    pull_number:\
          \ pr.number,\n    title: newTitle\n  });\n  core.info(`Titre mis √† jour:\
          \ \"${origTitle}\" ‚Üí \"${newTitle}\"`);\n} else {\n  core.info(\"Aucun changement\
          \ appliqu√© au titre.\");\n}\n"