name: Dev Server Check (PR)

on:
  pull_request:
    branches: [ develop, main ]

permissions:
  contents: read

concurrency:
  group: dev-server-check-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  dev-check:
    name: Pre-merge dev server checks
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # On mappe les secrets/vars dans l'env (utilisable dans les steps)
    env:
      REMOTE_TARGET: ${{ vars.REMOTE_TARGET || env.REMOTE_TARGET }}
      FTP_SERVER: ${{ secrets.FTP_SERVER }}
      FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
      FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
      SFTP_HOST: ${{ secrets.SFTP_HOST }}
      SFTP_USER: ${{ secrets.SFTP_USER }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # On calcule des flags "has_ftp" et "has_sftp" en sortie de step
      - name: Compute available transports
        id: flags
        shell: bash
        run: |
          set -euo pipefail
          has_ftp=true
          for v in FTP_SERVER FTP_USERNAME FTP_PASSWORD REMOTE_TARGET; do
            if [[ -z "${!v:-}" ]]; then
              has_ftp=false
            fi
          done

          has_sftp=true
          for v in SFTP_HOST SFTP_USER SSH_PRIVATE_KEY REMOTE_TARGET; do
            if [[ -z "${!v:-}" ]]; then
              has_sftp=false
            fi
          done

          echo "has_ftp=$has_ftp" >> "$GITHUB_OUTPUT"
          echo "has_sftp=$has_sftp" >> "$GITHUB_OUTPUT"

          echo "Detected:"
          echo "  has_ftp=$has_ftp"
          echo "  has_sftp=$has_sftp"

      # === FTP check (optionnel si secrets renseignés) ===
      - name: FTP list remote target
        if: ${{ steps.flags.outputs.has_ftp == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Listing ftp://$FTP_SERVER/$REMOTE_TARGET/"
          curl -sS --fail \
            --user "$FTP_USERNAME:$FTP_PASSWORD" \
            "ftp://$FTP_SERVER/$REMOTE_TARGET/" \
            | sed -n '1,60p'
          echo "✅ FTP reachable & target directory listable"

      # === SFTP check (optionnel si secrets renseignés) ===
      - name: Setup SSH key (SFTP)
        if: ${{ steps.flags.outputs.has_sftp == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_sftp
          chmod 600 ~/.ssh/id_sftp
          # known_hosts optionnel (sécurise la connexion si tu veux)
          ssh-keyscan -T 5 "$SFTP_HOST" 2>/dev/null >> ~/.ssh/known_hosts || true
          chmod 644 ~/.ssh/known_hosts

      - name: SFTP probe (write/list/delete)
        if: ${{ steps.flags.outputs.has_sftp == 'true' }}
        id: sftp_probe
        shell: bash
        run: |
          set -euo pipefail
          PROBE=".server-check-$(date -u +%Y%m%dT%H%M%SZ).txt"
          echo "ok $(date -u +%FT%TZ)" > "$PROBE"

          # Pas de heredoc YAML -> on pipe un batch SFTP
          printf '%s\n' \
            "cd $REMOTE_TARGET" \
            "put $PROBE" \
            "ls -l $PROBE" \
            "rm $PROBE" \
            "bye" \
          | sftp -b - -i ~/.ssh/id_sftp "${SFTP_USER}@${SFTP_HOST}"

          echo "✅ SFTP OK & remote dir writable"

      # Si aucun transport n'est disponible, on échoue explicitement
      - name: Fail if no transport available
        if: ${{ steps.flags.outputs.has_ftp != 'true' && steps.flags.outputs.has_sftp != 'true' }}
        shell: bash
        run: |
          echo "::error title=No transport configured::Neither FTP nor SFTP credentials are set. Provide secrets or disable this check."
          exit 1